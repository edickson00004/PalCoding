#include "model.h"
#include "interface.h"
#include <string.h>
#include <stddef.h>
#include <stdlib.h>
#include <stdio.h>
#include <ctype.h>
#include <stdbool.h>
#include <math.h>

#define TABLE_SIZE 70

//Structure of a cell, I am creating a new type: CellContent that I can assign to things to
//access if its a formula or not, and assign a value

typedef struct {
    int isFormula; //1 is formula 0 isnt
    union {
        double numericValue; // if text is number, its stored here
        char textValue[20]; // else if text is a string/char its stored here
    };
    char originalText[20];
} CellContent;

typedef struct {
    ROW row;
    COL col;
    CellContent content;
    struct CellEntry *next; // separate chaining ( linked list )
}CellEntry;

typedef struct{
    CellEntry *table[TABLE_SIZE];
}hashTable;

hashTable spreadsheet_table;

int hash(ROW row, COL col){
    char key[10];

    snprintf(key, sizeof(key), "%d%d", row, col); //

    int hashValue = 0;
    for (int i =0; i < strlen(key); i++){
        hashValue += key[i];
    }
    return hashValue % TABLE_SIZE;
}

int isFormula(const char *text){
    return (text[0] == '='); // formula checker, returns 1 if true 0 if false
}



// Function to evaluate a formula and return the result

double getCellValue(ROW row, COL col) {
    int foundIndex = hash(row, col);
    CellEntry *current = spreadsheet_table.table[foundIndex];

    while (current != NULL) {
        if (current->row == row && current->col == col) {
            return current->content.numericValue;
        }
        current = current->next;
    }

    return 0;
}

double evaluateFormula(const char *text) {
    double result = 0.0;
    char operator = '+';

    // Go through and evaluate the expression
    while (*text != '\0') {
        //Case 1: no cell dependencies just ints
        if (isdigit(*text)) {
            double operand = strtod(text, (char**)&text);
            switch(operator) {
                case '+':
                    result += operand;
                    break;
                case '-':
                    result -= operand;
                    break;
                case '/':
                    result /= operand;
                    break;
                case '*':
                    result *= operand;
                    break;
                case '%':
                    result = fmod(result, operand); //Need this because <stdio.h> doesn't support mod'ing doubles
                    break;
            }
        }
        else if (isalpha(*text)) { // Check if it's a column ( letter )
            COL col = *text - 'A'; //Converts char to integer ( ASCII function )
            text++;
            ROW row;
            row = strtol(text, (char**)&text, 10)-1; // was using scanf before but CLION told me to use, -1 to match the index

            // Lookup the cell value for the referenced cell
            double cellValue = getCellValue(row, col);
            switch (operator) {
                case '+':
                    result += cellValue;
                    break;
                case '-':
                    result -= cellValue;
                    break;
                case '*':
                    result *= cellValue;
                    break;
                case '/':
                    result /= cellValue;
                    break;
                case '%':
                    result = fmod(result, cellValue);
                    break;
            }
            // Skip to the next operator or the end of the text
            while (*text != '\0' && !strchr("+-*/%", *text))  //strchr searches the string looking for the value
            {
                text++;
            }
            operator = *text;
            text++;
        } else if (strchr("+-/*%", *text)) {
            operator = *text;
            text++;
        } else {
            text++;
        }
    }
    return result;
}



CellEntry *createHashNode(int index, ROW row, COL col, char *text) {
    CellEntry *newNode = (CellEntry *)malloc(sizeof(CellEntry));
    if (newNode == NULL) {
        return NULL;
    }

    newNode->row = row;
    newNode->col = col;
    newNode->next = spreadsheet_table.table[index];

    if (isFormula(text)) {

        newNode->content.isFormula = true;
        strcpy(newNode->content.originalText, text);
        double numericValue = evaluateFormula(text);
        newNode->content.numericValue = numericValue;
        strcpy(newNode->content.textValue, "");
    }
    else {

        newNode->content.isFormula = 0;

        char *endptr;
        double numericValue = strtod(text, &endptr);
        if (*endptr == '\0') {
            newNode->content.numericValue = numericValue;
        } else {
            strcpy(newNode->content.textValue, text);
        }
        strcpy(newNode->content.originalText, text);
    }

    spreadsheet_table.table[index] = newNode;
    update_cell_display(row, col, text);
    return newNode;
}





void model_init() {
    // TODO: implement this.
    for (int i =0; i < TABLE_SIZE; i++){
        spreadsheet_table.table[i] = NULL;
    }
}

void set_cell_value(ROW row, COL col, char *text) {
    // Find the desired index in my hashtable to store the current value
    int foundIndex = hash(row, col);
    CellEntry *current = spreadsheet_table.table[foundIndex];

    // Loop to the end of my hash table
    while (current != NULL) {
        if (current->row == row && current->col == col) { // Already exists, add into this index
            char *endptr = NULL;

            if (isFormula(text)) {
                strcpy(current->content.originalText, text);

                double numericValue = evaluateFormula(text); // Skip the '=' sign for formulas
                current->content.numericValue = numericValue;
                char numericValueStr[20]; // Assuming a maximum of 20 characters
                snprintf(numericValueStr, sizeof(numericValueStr), "%.2f", current->content.numericValue);
                update_cell_display(row, col, numericValueStr);
            }
            else {
                strcpy(current->content.originalText, text);
                double numericValue = strtod(text, &endptr);

                if (endptr != NULL && *endptr == '\0') {
                    current->content.numericValue = numericValue;
                    update_cell_display(row, col, text);

                }

                else {
                    if (current->content.isFormula) {
                        strcpy(current->content.originalText, text);
                        // Skip the '=' sign for formulas
                        strcpy(current->content.textValue, text + 1);
                        update_cell_display(row, col, text + 1);
                    } else {
                        strcpy(current->content.textValue, text);
                        update_cell_display(row, col, text);
                    }
                }
            }
            return;
        }
        // Move to the next entry
        (current) = (current->next);
    }

    // DNE, create a new cell
    CellEntry *newNode = createHashNode(foundIndex, row, col, text);

    // Check if the newly created cell is a formula
    if (newNode->content.isFormula) {
        double numberValue = evaluateFormula(text);
        newNode->content.numericValue = numberValue;
        char numericValueStr[20]; //Will increase if I need to support larger values
        snprintf(numericValueStr, sizeof(numericValueStr), "%.2f", newNode->content.numericValue);
        update_cell_display(row, col, numericValueStr);
    }
    else {
        update_cell_display(row, col, text);
    }

}



void clear_cell(ROW row, COL col) {
    // TODO: implement this.
    int foundIndex = hash(row, col);

    CellEntry *current = spreadsheet_table.table[foundIndex];
    CellEntry *prev = NULL;
    //want to set the numerical and text to empty

    while (current != NULL){
        if (current->row == row && current->col == col){
            current->content.isFormula = 0;
            current->content.numericValue = 0;
            current->content.textValue[0] = '\0';
            update_cell_display(row, col, "");

            if (prev == NULL) { // Remove from linked list
                spreadsheet_table.table[foundIndex] = current->next;
            } else {
                prev->next = current->next;
            }
            free(current);
            update_cell_display(row, col, "");
            return;

        }
        prev = current;
        current = current->next;
        update_cell_display(row, col, "");

    }

    // This just clears the display without updating any data structure. You will need to change this.
    update_cell_display(row, col, "");
}
char *get_textual_value(ROW row, COL col) {
    // Find the index in the hashtable
    int foundIndex = hash(row, col);
    CellEntry *current = spreadsheet_table.table[foundIndex];

    // Loop through the linked list at the specified index
    while (current != NULL) {
        if (current->row == row && current->col == col) {
            // Check if it's a text value
            if (current->content.textValue[0] != '\0') {// if theres no null character at the end it has to be a text val
                return strdup(current->content.originalText);
            }
            else  {
                char *result = (char *)malloc(20); //Creates the string for my numeric values
                if (result == NULL) { // Memory allocation error, shouldnt reach here
                    return NULL;
                }

                return strdup(current->content.originalText);

            }
        }
        current = current->next;
    }
    return NULL; // Base case, basically, null will be displaying unless im in a cell with a value
}
