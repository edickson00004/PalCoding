#include <assert.h>
#include <stdbool.h>
#include <stdlib.h>
#include <stdio.h>

typedef struct bst_node *bst;

struct bst_node {
    int value;
    bst left, right;
};

void bst_print_elements(bst tree) {
    if (tree != NULL) {
        bst_print_elements(tree->left);
        printf("%d, ", tree->value);
        bst_print_elements(tree->right);
    }
}

void bst_print(bst tree) {
    printf("{");
    bst_print_elements(tree);
    printf("}\n");
}

//creates a new leaf node
struct bst_node* newNode(int value){
    struct bst_node* newNode = (struct bst_node*)malloc(sizeof(struct bst_node));
    if(newNode != NULL){
        newNode->value = value;
        newNode->left = NULL;
        newNode->right = NULL;
    }
    return newNode;
}

bool bst_insert(bst *tree, int value) {
    // TODO: Task 1: insert 'value' into 'tree'.
    //worst time complexity occurs if you keep adding values that are greater than the last making basically a linked list which is O(n)
    if (*tree == NULL){
        *tree = newNode(value);
        return true;
    }
    if(value < (*tree)->value){
        return bst_insert(&(*tree)->left, value);
    }
    if(value >(*tree)->value){
        return bst_insert(&(*tree)->right, value);
    }

    if(value == (*tree)->value){
        return false;
    }

    printf("failed");
    return false;
}

//Need this inorder to find the value needed for swapping in case of 2 children
bst traverseRight(bst tree){
    while((tree)->left != NULL){
        (tree)= (tree)->left;
    }
    return tree;
}

bool bst_remove(bst *tree, int value) {
    // TODO: Task 2: remove 'value' from 'tree'.
    if(*tree == NULL){
        return false;
    }
    //if the value is bigger go onwards to the right subtree then recursively repeat
    else if((*tree)->value < value){
        return (bst_remove(&(*tree)->right, value));
    }
        //if the value is smaller go onwards to the left subtree then recursively repeat

    else if((*tree)->value > value){
        return (bst_remove(&(*tree)->left, value));
    }
    //we found value
    if((*tree)->value == value) {

        //case 1.0: 0 children, safe to remove the node
        if ((*tree)->left == NULL && (*tree)->right == NULL) {
            *tree = NULL;
            return true;
        }

            //case1.1: right child, point it to temp and rearrange pointer
        else if ((*tree)->left == NULL && (*tree)->right != NULL) {
            bst temp = *tree;
            *tree = (*tree)->right;
            free(temp);
            return true;
        }
            //case1.2: left child, same logic as above
        else if ((*tree)->right == NULL && (*tree)->left != NULL) {
            bst temp = *tree;
            *tree = (*tree)->left;
            free(temp);
            return true;
        }
        //worst case time complexity occurs here where it is o(logn)
            //Case 2: Double child // important to note that bst_remove)(&(*tree)->right is removing the duplicated subtree that is created
        else if((*tree)->right !=NULL && (*tree)->left != NULL){
            bst replacement = traverseRight((*tree)->right);
            (*tree)->value = replacement->value;
            bst_remove(&(*tree)->right, replacement->value);
            return true;
        }


    }

    return false;
}



void inorderTraverse(bst tree, bst *resultTree){
        //inorderTraverse the tree and add into a new tree
        if(tree != NULL) {
            inorderTraverse(tree->left, resultTree);
            inorderTraverse(tree->right, resultTree);
            bst_insert(resultTree, tree->value);
        }
}

bst bst_union(bst tree1, bst tree2) {
    //the time complexity of union relies on the slowest member which is inorderTraverse. For each traversal it inserts 1
    //resulting in o(n) time complexity
    bst resultTree = NULL;
    // Create empty tree
    inorderTraverse(tree1, &resultTree);
    // Traverse and add nodes from tree1 & tree2
    inorderTraverse(tree2, &resultTree);
    return resultTree;
}

bool traverse(bst tree, int value, bst *intersectionResult) {
    if (tree == NULL) {
        return false;
    }
    if (value == tree->value) {
        bst_insert(intersectionResult, value);
        return true;
        // Value found at the current node.
    }
    if (value < tree->value) {
        return traverse(tree->left, value, intersectionResult);
        // Search in the left subtree.
    } else {
        return traverse(tree->right, value, intersectionResult);
        // Search in the right subtree.
    }
}

bst intersectionTraversal(bst tree1, bst tree2, bst *intersectionResult){
    if(tree2 != NULL){
        // boolean function traverse returns true if the two values are =
        if (traverse(tree1, tree2->value, intersectionResult)) {
            bst_insert(intersectionResult, tree2->value); //insert into new tree
        }
        //Check left subtree
        intersectionTraversal(tree1, tree2->left, intersectionResult);
        //Check right subtree
        intersectionTraversal(tree1, tree2->right, intersectionResult);
    }
}

bst bst_intersection(bst tree1, bst tree2) {
    //the time complexity of traverse stops when it finds value1, and intersection traversal inserts once
    //this renders the time complexity as o(n) where n is the number of nodes in tree2
    // TODO: Task 3: compute the intersection of 'tree1' and 'tree2'.
    bst resultTree = NULL;
    intersectionTraversal(tree1, tree2, &resultTree);
    return resultTree;
}

int main() {
    // Initialize two trees.
    bst tree1 = NULL, tree2 = NULL;

    assert(bst_insert(&tree1, 1));
    assert(bst_insert(&tree1, 9));
    assert(bst_insert(&tree1, 2));
    assert(bst_insert(&tree1, 7));
    assert(bst_insert(&tree1, 0));
    assert(bst_insert(&tree1, 3));
    assert(bst_insert(&tree1, 13));
    assert(bst_insert(&tree1, 5));
    assert(!bst_insert(&tree1, 3));

    // Should print: {0, 1, 2, 3, 5, 7, 9, 13, }
    bst_print(tree1);


    assert(bst_insert(&tree2, 12));
    assert(bst_insert(&tree2, 13));
    assert(bst_insert(&tree2, 1));
    assert(bst_insert(&tree2, 0));
    assert(bst_insert(&tree2, 19));
    assert(bst_insert(&tree2, 7));
    assert(!bst_insert(&tree2, 13));
    assert(bst_insert(&tree2, 5));


    // Should print: {0, 1, 5, 7, 12, 13, 19, }
    bst_print(tree2);


    // Should print: {0, 1, 2, 3, 5, 7, 9, 12, 13, 19, }
    bst resultTree = NULL;
    inorderTraverse(tree2, &resultTree);
    bst union_1_2 = bst_union(tree1, tree2);
    bst_print(union_1_2);

    // Should print: {0, 1, 5, 7, 13, }
    bst intersection_1_2 = bst_intersection(tree1, tree2);
    bst_print(intersection_1_2);

    return 0;
}
